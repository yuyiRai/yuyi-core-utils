## API Report File for "yuyi-core-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { action } from 'mobx';
import { ArrayIterator } from 'lodash';
import assign from 'lodash/assign';
import camelCase from 'lodash/camelCase';
import cloneDeep from 'lodash/cloneDeep';
import { computed } from 'mobx';
import concat from 'lodash/concat';
import differenceWith from 'lodash/differenceWith';
import escapeRegExp from 'lodash/escapeRegExp';
import filter from 'lodash/filter';
import find from 'lodash/find';
import forEach from 'lodash/forEach';
import get from 'lodash/get';
import includes from 'lodash/includes';
import isArray from 'lodash/isArray';
import isArrayLike from 'lodash/isArrayLike';
import isBoolean from 'lodash/isBoolean';
import isDate from 'lodash/isDate';
import isEmpty from 'lodash/isEmpty';
import isFunction from 'lodash/isFunction';
import isNil from 'lodash/isNil';
import isObject from 'lodash/isObject';
import isRegExp from 'lodash/isRegExp';
import isString from 'lodash/isString';
import join from 'lodash/join';
import keys from 'lodash/keys';
import last from 'lodash/last';
import { List } from 'lodash';
import map from 'lodash/map';
import { Observable } from 'rxjs/internal/Observable';
import { observable } from 'mobx';
import property from 'lodash/property';
import { PropertyPath } from 'lodash';
import reduce from 'lodash/reduce';
import set from 'lodash/set';
import some from 'lodash/some';
import stubArray from 'lodash/stubArray';
import stubFalse from 'lodash/stubFalse';
import stubObject from 'lodash/stubObject';
import stubString from 'lodash/stubString';
import stubTrue from 'lodash/stubTrue';
import { Subject } from 'rxjs/internal/Subject';
import { Subscription } from 'rxjs/internal/Subscription';
import takeRight from 'lodash/takeRight';
import toArray from 'lodash/toArray';
import toString from 'lodash/toString';
import trim from 'lodash/trim';
import values from 'lodash/values';

// @public (undocumented)
export const AAA: {
    a: {
        b: {
            c: number;
        };
    };
};

// @public (undocumented)
export const AAAA: import("ts-optchain").TSOCDataAccessor<number>;

export { action }

// @public (undocumented)
export function App(param1: App.ParamA): any;

// @public (undocumented)
export namespace App {
    // (undocumented)
    export type ParamA = number;
}

export { ArrayIterator }

export { assign }

// Warning: (ae-forgotten-export) The symbol "AsyncComputedConfig" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export function asyncComputed<V = any>({ type, defaultValue, watcher, time }: AsyncComputedConfig<V>): PropertyDecorator;

// @public (undocumented)
export const BufferCacheGroup: {
    ___timeBufferList: Map<any, [EventEmitter<any>, Promise<any[]>, number]>;
    ___timeBufferValueMap: WeakMap<[EventEmitter<any>, Promise<any[]>, number], any>;
};

// @public (undocumented)
export type CallbackFunction<V> = (args?: V[]) => void;

export { camelCase }

// @public
export function castArray<T = any>(value: T | T[], allowEmpty?: boolean): T[];

// @public
export function castComputed<T, Args extends any[]>(computedFunc: Type.Function<Args, T>, ...computedArgs: Args): T;

// @public
export function castComputed<T extends NotFunction>(nativeValue: T, ...args: any[]): T;

// @public
export function castFunction<T = any>(withFunction: T): Type.Function<any[], T>;

// @public (undocumented)
export function castObjectArray(objOrArr: any[], allowEmpty?: boolean): any[];

// @public (undocumented)
export function castString(value: any): string;

export { cloneDeep }

// Warning: (ae-forgotten-export) The symbol "IKeyValueMap" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export class CommonDto<T extends object = IKeyValueMap> {
    // @deprecated (undocumented)
    protected $$___instance: {
        dto: T;
    };
    // (undocumented)
    protected $$___source_dto: T;
    constructor(dto: T);
    // (undocumented)
    clone(): T;
    createComputed(keyName: string): this & {
        [x: string]: any;
    };
    // (undocumented)
    equals(dto: T, deep?: boolean): boolean;
    // (undocumented)
    export(): T;
    get(keyNameStr: string, defaultValue?: any, useCreater?: boolean): string | number | boolean | object;
    // (undocumented)
    getAndCreateDeepPropertyByStr(keyStr: string, defaultValue: any): any;
    // (undocumented)
    getComputed: (keyName: string) => any;
    getPropertyByStr(keyName: string, defaultValue: any): any;
    hasComputed(keyName: string): boolean;
    set(keyName: string, value?: any, isSafe?: boolean): boolean;
    // (undocumented)
    setLastValue(keyName: string, value: any): boolean;
    // (undocumented)
    setPropertyByStr(keyName: string, value: any): boolean;
    // (undocumented)
    setSafeComputed(keyName: string): this & {
        [x: string]: any;
    };
}

export { computed }

export { concat }

// @public (undocumented)
export function connectTo(target: any, source: any, ...keyNames: string[]): boolean;

// @public (undocumented)
export function createCommonDto<M extends object>(model: M): CommonDto<M>;

// @public
export function createGroupWith<T extends object = any>(list: T[], keyOrWith: string | ((item: T) => string)): IKeyValueMap<T[]>;

// @public (undocumented)
export function createObjectKey(obj: any): string;

// @public (undocumented)
export function createSimpleTimeBufferInput<K extends object = Window, V = any>(callback: CallbackFunction<V>, instance: K, time: number, isDeepDiff?: boolean): (value: V) => Promise<any>;

// @public (undocumented)
export type DateFormatter = EDateFormatter | string;

export { differenceWith }

// @public
export function downloadFile(fileId: string, fileName: string): void;

// @public (undocumented)
export enum EDateFormatter {
    // (undocumented)
    date = "YYYY-MM-DD",
    // (undocumented)
    dateTime = "YYYY-MM-DD HH:mm:ss"
}

// @public
export const emptyObject: object;

export { escapeRegExp }

// @beta
export class EventEmitter<EventType = any> extends Subject<EventType> {
    // Warning: (ae-forgotten-export) The symbol "NextEvent" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ErrorEvent" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "CompletedEvent" needs to be exported by the entry point index.d.ts
    constructor(next?: NextEvent<EventType>, error?: ErrorEvent<EventType>, complete?: CompletedEvent<EventType>);
    dispose(): void;
    emit(value: EventType): void;
    getLastValue(): EventType;
    once(value: EventType): void;
    takeUntil(emit: Observable<any>): this;
    toPromise(): Promise<unknown>;
}

export { filter }

// Warning: (ae-forgotten-export) The symbol "IsBaseType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IsArray" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IsObject" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "IsAny" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export type FilterFunction<T = any> = <ST extends (IsBaseType<T, T, (IsArray<T, any, (IsObject<T, any, (IsAny<T, any, T>)>)>)>) = any>(...key: any[]) => (IsBaseType<T, T, (IsArray<T, Array<ST>, (IsObject<T, IsObject<ST, ST, IKeyValueMap<ST>>, (IsAny<ST, T, ST>)>)>)>) | undefined;

export { find }

export { forEach }

export { get }

// @public (undocumented)
export function getDtoOrFormValue(key: string, formOrDto: any): any;

// Warning: (ae-incompatible-release-tags) The symbol "getEventEmitter" is marked as @public, but its signature references "EventEmitter" which is marked as @beta
// 
// @public (undocumented)
export function getEventEmitter(): EventEmitter<any>;

// Warning: (ae-forgotten-export) The symbol "PrototeryMatcher" needs to be exported by the entry point index.d.ts
// 
// @public
export function getExpressByStr(keyStr: string, defaultValue: any): PrototeryMatcher[];

// @public (undocumented)
export function getListDifferent(listA: any[], listB: any[], deep?: boolean): {
    push: any[];
    pull: any[];
};

// @public (undocumented)
export function getPropByPath(obj: any, path: string, strict?: boolean): {
    o: any;
    k: string;
    v: any;
};

// @public
export function getPropertyFieldByCreate<V = any>(main: IKeyValueMap, ...proteryNames: PrototeryMatcher[]): V;

// @public
export function getRealLength(str: string): number;

export { includes }

// @public (undocumented)
export namespace IOptionsUtils {
    // (undocumented)
    export type keyMatcher = (key?: string, arg1?: any, arg2?: any) => boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "KeyMatcherFunc" is marked as @public, but its signature references "Option" which is marked as @beta
    export type KeyMatcherFunc = (keyMatcher: keyMatcher, item: Option) => boolean;
    // @beta
    export interface Option {
        // (undocumented)
        [key: string]: any;
        // (undocumented)
        children?: Option[];
        // (undocumented)
        disabled?: boolean;
        // (undocumented)
        isLeaf?: boolean;
        // (undocumented)
        label?: string;
        // (undocumented)
        value?: string;
    }
    // Warning: (ae-incompatible-release-tags) The symbol "OptionBase" is marked as @public, but its signature references "Option" which is marked as @beta
    // 
    // (undocumented)
    export type OptionBase = Option | string;
    // Warning: (ae-incompatible-release-tags) The symbol "OptionSearcher" is marked as @public, but its signature references "Option" which is marked as @beta
    // 
    // (undocumented)
    export type OptionSearcher = (key?: string, isOnlySearch?: boolean) => Promise<Option[]>;
    // Warning: (ae-incompatible-release-tags) The symbol "RemoteSearcher" is marked as @public, but its signature references "Option" which is marked as @beta
    // 
    // (undocumented)
    export type RemoteSearcher = (key: string, isOnlySearch?: boolean) => Promise<Option[]>;
    // (undocumented)
    export type SearchKey<T = any> = keyMatcher | RegExp | T[] | T;
}

// @public (undocumented)
export interface IPropertyUtils {
    // (undocumented)
    asyncComputed: typeof asyncComputed;
    // Warning: (ae-forgotten-export) The symbol "get" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    get: typeof get_2;
    // (undocumented)
    getExpressByStr: typeof getExpressByStr;
    // (undocumented)
    getPropByPath: typeof getPropByPath;
    // (undocumented)
    getPropertyFieldByCreate: typeof getPropertyFieldByCreate;
    // Warning: (ae-forgotten-export) The symbol "set" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    set: typeof set_2;
}

export { isArray }

export { isArrayLike }

export { isBoolean }

// @public (undocumented)
export function isBooleanOrNumber(value: any): value is (boolean | number);

export { isDate }

export { isEmpty }

// @public (undocumented)
export function isEmptyArray(value: any): value is boolean;

// @public (undocumented)
export function isEmptyArrayStrict(value: any): value is any[];

// @public (undocumented)
export function isEmptyData(value: any): value is any[];

// @public (undocumented)
export function isEmptyObject(value: any, checkValue?: boolean): value is {};

// @public
export function isEmptyValue(value: any): value is (null | undefined | '');

// @public (undocumented)
export function isEqual(valueA: any, valueB: any, noStrict?: boolean): boolean;

// @public (undocumented)
export namespace isEqual {
    const // (undocumented)
    _: (value: any, other: any) => boolean;
}

// Warning: (ae-incompatible-release-tags) The symbol "isEventEmitter" is marked as @public, but its signature references "EventEmitter" which is marked as @beta
// 
// @public (undocumented)
export function isEventEmitter(emitter: any): emitter is EventEmitter;

export { isFunction }

export { isNil }

// @public (undocumented)
export function isNilAll(...valueArr: any[]): boolean;

// @public (undocumented)
export function isNotEmptyArray(value: any): value is any[];

// @public (undocumented)
export function isNotEmptyArrayStrict(value: any): value is any[];

// @public (undocumented)
export function isNotEmptyData(value: any): boolean;

// @public (undocumented)
export function isNotEmptyObject(value: any): value is object;

// @public
export function isNotEmptyString(str: any): str is string;

// @public
export function isNotEmptyValue(value: any): value is (string | number | boolean | object | Function);

// @public (undocumented)
export function isNotFunction(func: any): boolean;

// @public (undocumented)
export function isNotNaN(v: any): boolean;

// @public
export function isNumber(value: any, allowNaN?: boolean): value is number;

// @public (undocumented)
export namespace isNumber {
    const // (undocumented)
    _: (value?: any) => value is number;
    const // (undocumented)
    _NaN: (value?: any) => boolean;
}

export { isObject }

export { isRegExp }

export { isString }

// @public (undocumented)
export interface ITypeFilterUtils {
    // (undocumented)
    isArrayFilter: FilterFunction<Array<any>>;
    // (undocumented)
    isBooleanFilter: FilterFunction<boolean>;
    // (undocumented)
    isFunctionFilter: FilterFunction<(...arg: any[]) => any>;
    // (undocumented)
    isNotEmptyArrayFilter: FilterFunction<Array<any>>;
    // (undocumented)
    isNotEmptyStringFilter: FilterFunction<string>;
    // (undocumented)
    isNotEmptyValueFilter: FilterFunction;
    // (undocumented)
    isNumberFilter: FilterFunction<number>;
    // (undocumented)
    isObjectFilter: FilterFunction<object>;
    // (undocumented)
    isStringFilter: FilterFunction<string>;
}

// Warning: (ae-forgotten-export) The symbol "Type" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export interface ITypeUtils extends Type<typeof typeUtils>, ITypeFilterUtils {
}

export { join }

// @public
export function jsGetAge(strBirthday: string): any;

export { keys }

export { last }

// Warning: (ae-forgotten-export) The symbol "CustomUtils" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export const likeArray: typeof CustomUtils.likeArray;

// @public (undocumented)
export function logger<P extends any = any>(name?: string, time?: boolean): (target: any, methodName: string, descriptor: PropertyDescriptor) => void;

export { map }

// @public (undocumented)
export type NotFunction = string | symbol | object | number | boolean;

export { observable }

// @beta
export class OptionsUtils {
    // (undocumented)
    static convertValueOption(valueList: string[], isFull?: boolean): IOptionsUtils.Option[];
    static createEqualsMatcher<K = any>(searchKey: IOptionsUtils.SearchKey<K>): IOptionsUtils.keyMatcher;
    // (undocumented)
    static getCodeListByKey(codeType: IOptionsUtils.Option[]): IOptionsUtils.RemoteSearcher;
    // (undocumented)
    static getCodeListByKey(codeType: IOptionsUtils.OptionSearcher, optionFactory?: ArrayIterator<IKeyValueMap, IOptionsUtils.Option>): IOptionsUtils.RemoteSearcher;
    // Warning: (ae-forgotten-export) The symbol "IsTrue" needs to be exported by the entry point index.d.ts
    static getOptions<TOption = IOptionsUtils.Option, FindOne extends boolean = false, TResult = IsTrue<FindOne, TOption | undefined, TOption[]>>(optionList: TOption[], searchKey: IOptionsUtils.SearchKey<any>, keyMatcherFunc: IOptionsUtils.KeyMatcherFunc, findOne?: FindOne): TResult;
    static getOptionsByKey<T = IOptionsUtils.Option, K = string>(optionList: T[], searchKey: IOptionsUtils.SearchKey<K>, findOne?: boolean): T | T[] | undefined;
    static getOptionsByLabel<T = IOptionsUtils.Option, K = string>(optionList: T[], searchName: IOptionsUtils.SearchKey<K>): T[];
    static getOptionsByLabel<T = IOptionsUtils.Option, K = string>(optionList: T[], searchName: IOptionsUtils.SearchKey<K>, findOne: true): T | undefined;
    static getOptionsByValue<T = IOptionsUtils.Option, K = string>(optionList: T[], searchValue: IOptionsUtils.SearchKey<K>, findOne: true): T | undefined;
    static getOptionsByValue<T = IOptionsUtils.Option, K = string>(optionList: T[], searchValue: IOptionsUtils.SearchKey<K>): T[];
    // (undocumented)
    static isLabelMatchedItem(labelSearcher: IOptionsUtils.SearchKey<string>, item: IOptionsUtils.Option): boolean;
    static isLabelMatchedItemByMatcher(keyMatcher: IOptionsUtils.keyMatcher, item: IOptionsUtils.Option): boolean;
    static isOptionsItemSelected<T, K>(option: T[], searchName: IOptionsUtils.SearchKey<K>, selectedValue: IOptionsUtils.SearchKey<K>): boolean;
    // (undocumented)
    static isValueMatchedItem(valueSearcher: IOptionsUtils.SearchKey<string>, item: IOptionsUtils.Option): boolean;
    static isValueMatchedItemByMatcher(keyMatcher: IOptionsUtils.keyMatcher, item: IOptionsUtils.Option): boolean;
    // (undocumented)
    static labelsToValues(options: IOptionsUtils.Option[], label: IOptionsUtils.SearchKey<string>): string[];
    // (undocumented)
    static labelsToValues(options: IOptionsUtils.Option[], label: IOptionsUtils.SearchKey<string>, joinKey: string): string;
    // (undocumented)
    static labelToValue(optionList: IOptionsUtils.Option[], label: IOptionsUtils.SearchKey<string>): string | undefined;
    // (undocumented)
    static optionsSelectedMatch<T, K>(option: T[], searchName: IOptionsUtils.SearchKey<K>): IOptionsUtils.keyMatcher;
    // (undocumented)
    static valuesToLabels(options: IOptionsUtils.Option[], value: IOptionsUtils.SearchKey<string>): string[];
    // (undocumented)
    static valuesToLabels(options: IOptionsUtils.Option[], value: IOptionsUtils.SearchKey<string>, joinKey: string): string;
    // (undocumented)
    static valueToLabel(optionList: IOptionsUtils.Option[], value: IOptionsUtils.SearchKey<string>): string | undefined;
}

// @public
export function parseTime(time: any, cFormat?: string): string;

// @public
export function pipe(data: any, ...funcArr: any[]): any;

export { property }

export { reduce }

// @public (undocumented)
export namespace reduceExtra {
    export function map<T, Result extends IKeyValueMap, TResult = {
        [K in keyof T]?: Result;
    }>(collection: List<T> | T[] | null | undefined, callback: ReduceMapObjectIterator<List<T> | T[] | null | undefined, Result, TResult>, accumulator?: TResult): TResult;
    // (undocumented)
    export function map<T extends IKeyValueMap, Result = any, TResult = {
        [K in keyof T]?: Result;
    }>(collection: T | null | undefined, callback: ReduceMapObjectIterator<T, Result, TResult>, accumulator?: TResult): TResult;
    // (undocumented)
    export type ReduceMapObjectIterator<TSource = any, Result = TSource[keyof TSource], TResult = {
        [K in keyof TSource]?: Result;
    }> = (curr: TSource[keyof TSource], key: keyof TSource, source: TSource, prev: TResult) => TResult;
}

export { set }

// Warning: (ae-incompatible-release-tags) The symbol "simpleTimeBuffer" is marked as @public, but its signature references "EventEmitter" which is marked as @beta
// 
// @public
export function simpleTimeBuffer<V = any>(time: number, isDeepDiff: boolean, callback: CallbackFunction<V>, emitter?: EventEmitter<V>): TimeBufferConfig<V>;

// @public (undocumented)
export function simpleTimeBufferInput<K extends object, V = any>(key: K, value: V, callback: CallbackFunction<V>, time: number, isDeepDiff?: boolean): Promise<any>;

export { some }

export { stubArray }

export { stubFalse }

// @public
export function stubFunction(...args: any[]): void;

export { stubObject }

// @public
export function stubObjectStatic(): object;

export { stubString }

export { stubTrue }

export { Subscription }

export { takeRight }

// @public (undocumented)
export const testGroup: {
    shareTest(...data: any[]): void;
};

// @public (undocumented)
export function timebuffer(time: number, mode?: string): (target: any, methodName: string, descriptor: PropertyDescriptor) => void;

// Warning: (ae-incompatible-release-tags) The symbol "TimeBufferConfig" is marked as @public, but its signature references "EventEmitter" which is marked as @beta
// 
// @public (undocumented)
export type TimeBufferConfig<V> = [EventEmitter<V>, Promise<V[]>, number];

export { toArray }

// @public (undocumented)
export function toDateString(value: any, formatter?: DateFormatter): Date | string;

// @public (undocumented)
export function todoFilter(handler: (v: any) => boolean): FilterFunction;

export { toString }

export { trim }

// @public (undocumented)
export const typeFilterUtils: ITypeFilterUtils;

// @public (undocumented)
export const typeUtils: {
    isArrayLike: {
        <T extends {
            __lodashAnyHack: any;
        }>(t: T): boolean;
        (value: (...args: any[]) => any): value is never;
        (value: any): value is {
            length: number;
        };
    };
    isArray: {
        (value?: any): value is any[];
        <T>(value?: any): value is any[];
    };
    isBoolean: (value?: any) => value is boolean;
    isObject: (value?: any) => value is object;
    isNumber: typeof isNumber;
    isString: (value?: any) => value is string;
    isEmptyData: typeof isEmptyData;
    isNotEmptyData: typeof isNotEmptyData;
    isEventEmitter: typeof isEventEmitter;
    isNotEmptyString: typeof isNotEmptyString;
    isFunction: (value: any) => value is (...args: any[]) => any;
    isNil: (value: any) => value is null;
    isDate: (value?: any) => value is Date;
    isNaN: typeof isNaN;
    isNotFunction: typeof isNotFunction;
    isNotNaN: typeof isNotNaN;
    isNilAll: typeof isNilAll;
    isBooleanOrNumber: typeof isBooleanOrNumber;
    isEmptyValue: typeof isEmptyValue;
    isNotEmptyValue: typeof isNotEmptyValue;
    isEmptyArray: typeof isEmptyArray;
    isNotEmptyArray: typeof isNotEmptyArray;
    isEmptyArrayStrict: typeof isEmptyArrayStrict;
    isNotEmptyArrayStrict: typeof isNotEmptyArrayStrict;
    isEmptyObject: typeof isEmptyObject;
    isNotEmptyObject: typeof isNotEmptyObject;
};

// @public
export function uuid(): string;

export { values }

// @public
export function zipEmptyData<T = any>(target: Array<T | undefined | null>, isRemoveRepeat?: boolean): T[];

// @public (undocumented)
export function zipEmptyData<T = any>(target: IKeyValueMap<T | undefined | null>, isRemoveRepeat?: boolean): IKeyValueMap<T>;


// Warnings were encountered during analysis:
// 
// src/TimeBuffer.ts:76:30 - (ae-incompatible-release-tags) The symbol "___timeBufferList" is marked as @public, but its signature references "EventEmitter" which is marked as @beta
// src/TimeBuffer.ts:76:30 - (ae-incompatible-release-tags) The symbol "___timeBufferValueMap" is marked as @public, but its signature references "EventEmitter" which is marked as @beta

```
